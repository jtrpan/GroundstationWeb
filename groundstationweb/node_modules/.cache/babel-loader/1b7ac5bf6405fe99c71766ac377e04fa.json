{"ast":null,"code":"import rungeKutta4 from 'ode-rk4';\n/* Predictions.js takes in information about an object being dropped from a moving\r\nplane and calculates the object's predicted distance (x-position) from its origin (x0, y0)\r\nonce it reaches the ground (y = height = 0).\r\n\r\nIt requires a system of 4 ODEs, and uses an implementation of RungeKutta (rk4) in ode-rk4 library.\r\nto solve the system.\r\n\r\nAll units are calculated in metric system. The program assumes an input in ft and thus produces an output in ft.\r\nInitial altitude is in ft, velocity should be in [m/s].\r\n\r\nThe code below is based on the following paper\r\n https://www.phys.uconn.edu/~rozman/Courses/P2200_14F/downloads/glider/glider-2014-11-05.pdf\r\n All variable names have been translated to descriptive variables\r\n ## notation indicates the equivalent variable used in the paper for reference\r\n [ ] notation indicates units\r\n*/\n\nconst CDA_CL = 0.9;\nconst CDA_CD = 0.3;\nconst PAYLOAD_CD = 3.75; // ----------- Constants-----------\n// ________________________________\n\nconst m2ft = 3.281; // #of ft in 1 m\n\nconst gravity = 9.81; // ## g [m/s^2]\n// air density at sea level & 15ºC, may need to be adjusted\n\nconst airDensity = 1.2; // ## rho -> 𝞺 [kg/m^3]\n\nexport const predict = (currentAngle, currentAltitude, initialVelocity, velocityScalingFactor, derivFunctions) => {\n  // -----------Dependent Variables-----------\n  // __________________________________________\n  // Check that altitude is non-negative:\n  if (currentAltitude < 0) {\n    currentAltitude = 0.0;\n  } // scaling factors for dimensionless variables, no units.\n  // √[(m * g) /(1/2)(𝞺)(Cd or Cl)(S)], ### dragOrLiftScalingFactor = Cd or Cl based on desired application, S = wingArea, 𝞺 = air density\n\n\n  const distanceScalingFactor = velocityScalingFactor ** 2 / gravity; // ## lc -> = vt^2/g\n  // Initial Conditions\n\n  const initialDistance = 0 / m2ft; // ## x0 [m] -> initial distance in x position of object, corresponds to pos of plane at drop\n\n  const initialHeight = currentAltitude / m2ft; // ## y0 [m]\n\n  const initialAngle = currentAngle; // ## theta, [rad] -> angle w.r.t horizon, doesn't need to be dimensionless\n  // -----------Dimensionless Variables----------- (see linked paper for more info)\n  // ______________________________________________\n\n  const initialDistanceScaled = initialDistance / distanceScalingFactor;\n  const initialHeightScaled = initialHeight / distanceScalingFactor;\n  const initialVelocityScaled = initialVelocity / velocityScalingFactor; // ----------- Runge Kutta Integrator Variables-----------\n  // _______________________________________________________\n\n  const initialConditions = [initialVelocityScaled, initialAngle, initialDistanceScaled, initialHeightScaled]; // initial conditions in RK4 to be solved for\n\n  const numberOfSteps = 90; // number of maximum steps taken by RK4 to solve the system\n\n  const initalTime = 0; // start time\n\n  const h = 2.0 * Math.PI / numberOfSteps; // small number used as a coefficient in Runge Kutta Method\n  // Function to unscale variables after being solved using RK4\n\n  const unscale = output => {\n    return [output[0] * velocityScalingFactor, // returns unscaled velocity\n    output[1], // returns angle w.r.t horizon\n    output[2] * distanceScalingFactor * m2ft, // returns unscaled x position\n    output[3] * distanceScalingFactor * m2ft // returns unscaled y position\n    ];\n  }; // ----------- Solve System of ODE & return result-----------\n  // _______________________________________________________\n\n\n  const rk4Solver = rungeKutta4(initialConditions, derivFunctions, initalTime, h);\n  let output; // solve ODE using RK4, stop once object has hit the ground (y[3] = height = 0)\n\n  do {\n    output = rk4Solver.step();\n  } while (output.y[3] > 0); // check if object has reach ground\n\n\n  return unscale(output.y)[2]; // return x position after object reaches ground\n}; // Prediction Setup for an object dropped from a plane\n\nexport const predictPayload = (altitude, velocity, headwind, angle) => {\n  if (velocity <= 0.05) {\n    return 0;\n  } // coeffDrag = PAYLOAD_CD, //## Cd\n\n\n  const mass = 0.5; // ## m [kg]\n\n  const wingArea = 0.019; // ## S [m^2]\n\n  const velocityScalingFactor = Math.sqrt(mass * gravity / (0.5 * airDensity * PAYLOAD_CD * wingArea)); // ## vt\n\n  const headwindScaled = headwind / velocityScalingFactor; // dydt[] = derivative functions for each of θ, v, x, y.\n  // y -> y[0] = v, y[1] = theta\n\n  const derivFunctions = (dydt, y) => {\n    dydt[0] = -Math.sin(y[1]) - y[0] * y[0]; // ## dvdt\n\n    dydt[1] = -Math.cos(y[1]) / y[0]; // ## dθdt\n\n    dydt[2] = y[0] * Math.cos(y[1]) - headwindScaled; // ## dxdt\n\n    dydt[3] = y[0] * Math.sin(y[1]); // ## dydt\n  };\n\n  return predict(angle, altitude, velocity, velocityScalingFactor, derivFunctions);\n}; // Prediction setup for a glider released from a plane\n\nexport const predictCDA = (altitude, velocity, headwind, angle) => {\n  if (velocity <= 0.05) {\n    return 0;\n  } // coeffLift = CDA_CL,// ## Cl\n  // coeffDrag = CDA_CD,// ## Cd\n\n\n  headwind -= velocity;\n  const mass = 0.227; // ## m [kg]\n\n  const wingArea = 0.056; // ## S [m^2]\n\n  const headwindFOS = 0.25; // scale headwind (increase) and scale tailwind (decrease) to assume worst case effect of headwind\n\n  const velocityScalingFactor = Math.sqrt(mass * gravity / (0.5 * airDensity * CDA_CL * wingArea)); // ## vt\n\n  let headwindScaled;\n\n  if (headwind > 0) {\n    headwindScaled = headwind * (1.0 + headwindFOS) / velocityScalingFactor;\n  } else {\n    headwindScaled = headwind * (1.0 - headwindFOS) / velocityScalingFactor;\n  }\n\n  const liftToDragRatio = CDA_CL / CDA_CD; // ## R -> Glide Ratio\n  // dydt[] = derivative functions for each of θ, v, x, y.\n  // y -> y[0] = v, y[1] = theta\n\n  const deriv = (dydt, y) => {\n    dydt[0] = -Math.sin(y[1]) - y[0] ** 2 / liftToDragRatio; // ## dvdt\n\n    dydt[1] = -Math.cos(y[1]) / y[0] + y[0]; // ## dθdt\n\n    dydt[2] = y[0] * Math.cos(y[1]) - headwindScaled; // ## dxdt // scaledHeadwind needs to be constant\n\n    dydt[3] = y[0] * Math.sin(y[1]); // ## dydt\n  };\n\n  return predict(angle, altitude, velocity, velocityScalingFactor, deriv);\n};","map":{"version":3,"sources":["C:/Users/James Pan/Documents/UBC/demo/groundstationweb/src/helpers/predictions.js"],"names":["rungeKutta4","CDA_CL","CDA_CD","PAYLOAD_CD","m2ft","gravity","airDensity","predict","currentAngle","currentAltitude","initialVelocity","velocityScalingFactor","derivFunctions","distanceScalingFactor","initialDistance","initialHeight","initialAngle","initialDistanceScaled","initialHeightScaled","initialVelocityScaled","initialConditions","numberOfSteps","initalTime","h","Math","PI","unscale","output","rk4Solver","step","y","predictPayload","altitude","velocity","headwind","angle","mass","wingArea","sqrt","headwindScaled","dydt","sin","cos","predictCDA","headwindFOS","liftToDragRatio","deriv"],"mappings":"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","sourcesContent":["import rungeKutta4 from 'ode-rk4';\r\n\r\n/* Predictions.js takes in information about an object being dropped from a moving\r\nplane and calculates the object's predicted distance (x-position) from its origin (x0, y0)\r\nonce it reaches the ground (y = height = 0).\r\n\r\nIt requires a system of 4 ODEs, and uses an implementation of RungeKutta (rk4) in ode-rk4 library.\r\nto solve the system.\r\n\r\nAll units are calculated in metric system. The program assumes an input in ft and thus produces an output in ft.\r\nInitial altitude is in ft, velocity should be in [m/s].\r\n\r\nThe code below is based on the following paper\r\n https://www.phys.uconn.edu/~rozman/Courses/P2200_14F/downloads/glider/glider-2014-11-05.pdf\r\n All variable names have been translated to descriptive variables\r\n ## notation indicates the equivalent variable used in the paper for reference\r\n [ ] notation indicates units\r\n*/\r\n\r\nconst CDA_CL = 0.9;\r\nconst CDA_CD = 0.3;\r\nconst PAYLOAD_CD = 3.75;\r\n\r\n// ----------- Constants-----------\r\n// ________________________________\r\nconst m2ft = 3.281; // #of ft in 1 m\r\nconst gravity = 9.81; // ## g [m/s^2]\r\n\r\n// air density at sea level & 15ºC, may need to be adjusted\r\nconst airDensity = 1.2; // ## rho -> 𝞺 [kg/m^3]\r\n\r\nexport const predict = (currentAngle, currentAltitude, initialVelocity, velocityScalingFactor, derivFunctions) => {\r\n  // -----------Dependent Variables-----------\r\n  // __________________________________________\r\n\r\n  // Check that altitude is non-negative:\r\n  if (currentAltitude < 0) {\r\n    currentAltitude = 0.0;\r\n  }\r\n\r\n  // scaling factors for dimensionless variables, no units.\r\n  // √[(m * g) /(1/2)(𝞺)(Cd or Cl)(S)], ### dragOrLiftScalingFactor = Cd or Cl based on desired application, S = wingArea, 𝞺 = air density\r\n  const distanceScalingFactor = (velocityScalingFactor ** 2) / gravity; // ## lc -> = vt^2/g\r\n\r\n  // Initial Conditions\r\n  const initialDistance = 0/m2ft; // ## x0 [m] -> initial distance in x position of object, corresponds to pos of plane at drop\r\n  const initialHeight = currentAltitude/m2ft; // ## y0 [m]\r\n  const initialAngle = currentAngle; // ## theta, [rad] -> angle w.r.t horizon, doesn't need to be dimensionless\r\n\r\n\r\n  // -----------Dimensionless Variables----------- (see linked paper for more info)\r\n  // ______________________________________________\r\n  const initialDistanceScaled = initialDistance/distanceScalingFactor;\r\n  const initialHeightScaled = initialHeight/distanceScalingFactor;\r\n  const initialVelocityScaled = initialVelocity/velocityScalingFactor;\r\n\r\n\r\n  // ----------- Runge Kutta Integrator Variables-----------\r\n  // _______________________________________________________\r\n  const initialConditions = [initialVelocityScaled, initialAngle, initialDistanceScaled, initialHeightScaled]; // initial conditions in RK4 to be solved for\r\n  const numberOfSteps = 90; // number of maximum steps taken by RK4 to solve the system\r\n  const initalTime = 0; // start time\r\n  const h = 2.0 * Math.PI / numberOfSteps; // small number used as a coefficient in Runge Kutta Method\r\n\r\n\r\n  // Function to unscale variables after being solved using RK4\r\n  const unscale = (output) => {\r\n    return [\r\n      output[0] * velocityScalingFactor, // returns unscaled velocity\r\n      output[1], // returns angle w.r.t horizon\r\n      output[2] * distanceScalingFactor * m2ft, // returns unscaled x position\r\n      output[3] * distanceScalingFactor * m2ft, // returns unscaled y position\r\n    ];\r\n  };\r\n\r\n\r\n  // ----------- Solve System of ODE & return result-----------\r\n  // _______________________________________________________\r\n  const rk4Solver = rungeKutta4(initialConditions, derivFunctions, initalTime, h);\r\n\r\n  let output;\r\n  // solve ODE using RK4, stop once object has hit the ground (y[3] = height = 0)\r\n  do {\r\n    output = rk4Solver.step();\r\n  } while (output.y[3] > 0); // check if object has reach ground\r\n\r\n  return unscale(output.y)[2]; // return x position after object reaches ground\r\n};\r\n\r\n// Prediction Setup for an object dropped from a plane\r\nexport const predictPayload = (altitude, velocity, headwind, angle) => {\r\n  if (velocity <= 0.05) {\r\n    return 0;\r\n  }\r\n\r\n  // coeffDrag = PAYLOAD_CD, //## Cd\r\n  const mass = 0.5; // ## m [kg]\r\n  const wingArea = 0.019; // ## S [m^2]\r\n  const velocityScalingFactor = Math.sqrt(mass * gravity/(0.5 * airDensity * PAYLOAD_CD * wingArea)); // ## vt\r\n  const headwindScaled = headwind/velocityScalingFactor;\r\n\r\n  // dydt[] = derivative functions for each of θ, v, x, y.\r\n  // y -> y[0] = v, y[1] = theta\r\n  const derivFunctions = (dydt, y) => {\r\n    dydt[0] = -Math.sin(y[1]) - (y[0] * y[0]); // ## dvdt\r\n    dydt[1] = -Math.cos(y[1]) / y[0]; // ## dθdt\r\n    dydt[2] = y[0] * Math.cos(y[1]) - headwindScaled; // ## dxdt\r\n    dydt[3] = y[0] * Math.sin(y[1]); // ## dydt\r\n  };\r\n\r\n  return predict(angle, altitude, velocity, velocityScalingFactor, derivFunctions);\r\n};\r\n\r\n// Prediction setup for a glider released from a plane\r\nexport const predictCDA = (altitude, velocity, headwind, angle) => {\r\n  if (velocity <= 0.05) {\r\n    return 0;\r\n  }\r\n  // coeffLift = CDA_CL,// ## Cl\r\n  // coeffDrag = CDA_CD,// ## Cd\r\n  headwind -= velocity;\r\n  const mass = 0.227; // ## m [kg]\r\n  const wingArea = 0.056; // ## S [m^2]\r\n  const headwindFOS = 0.25; // scale headwind (increase) and scale tailwind (decrease) to assume worst case effect of headwind\r\n  const velocityScalingFactor = Math.sqrt(mass * gravity/(0.5 * airDensity * CDA_CL* wingArea)); // ## vt\r\n  let headwindScaled;\r\n\r\n  if (headwind > 0) {\r\n    headwindScaled = headwind*(1.0 + headwindFOS)/velocityScalingFactor;\r\n  } else {\r\n    headwindScaled = headwind*(1.0 - headwindFOS)/velocityScalingFactor;\r\n  }\r\n\r\n\r\n  const liftToDragRatio = CDA_CL/CDA_CD; // ## R -> Glide Ratio\r\n\r\n  // dydt[] = derivative functions for each of θ, v, x, y.\r\n  // y -> y[0] = v, y[1] = theta\r\n  const deriv = (dydt, y) => {\r\n    dydt[0] = -Math.sin(y[1]) - (y[0] ** 2)/liftToDragRatio; // ## dvdt\r\n    dydt[1] = -Math.cos(y[1]) / y[0] + y[0]; // ## dθdt\r\n    dydt[2] = y[0] * Math.cos(y[1]) - headwindScaled; // ## dxdt // scaledHeadwind needs to be constant\r\n    dydt[3] = y[0] * Math.sin(y[1]); // ## dydt\r\n  };\r\n  return predict(angle, altitude, velocity, velocityScalingFactor, deriv);\r\n};\r\n"]},"metadata":{},"sourceType":"module"}