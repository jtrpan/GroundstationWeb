{"ast":null,"code":"const newLatitudeOfObject = (currentLatRad, angularDistance, directionRad) => {\n  return Math.asin(Math.sin(currentLatRad) * Math.cos(angularDistance) + Math.cos(currentLatRad) * Math.sin(angularDistance) * Math.cos(directionRad));\n};\n\nconst newLongitudeOfObject = (currentLatRad, currentLongRad, newLatRad, angularDistance, directionRad) => {\n  return currentLongRad + Math.atan2(Math.sin(directionRad) * Math.sin(angularDistance) * Math.cos(currentLatRad), Math.cos(angularDistance) - Math.sin(currentLatRad) * Math.sin(newLatRad));\n};\n\nconst toDegrees = rad => {\n  return rad * 180 / Math.PI;\n};\n\nconst toRadians = angle => {\n  return angle * Math.PI / 180;\n}; // Calculate the angular distance w.r.t mean earth radius\n// Assumes distance in ft;\n\n\nconst calcAngularDistance = distance => {\n  const earthRadius = 6378100; // average earth radius in m;\n\n  const feetInM = 3.218; // number of ft in 1m\n\n  const distanceInM = distance / feetInM;\n  return distanceInM / earthRadius;\n}; // Calculate new position of object in degrees (latitude & longitude)\n// based on https://www.movable-type.co.uk/scripts/latlong.html#dest-point\n\n\nconst calculateNewPositionOfObject = (currentLatitude, currentLongitude, distance, direction) => {\n  const angularDistance = calcAngularDistance(distance);\n  const currentLatRad = toRadians(currentLatitude);\n  const currentLongRad = toRadians(currentLongitude);\n  const directionRad = toRadians(direction);\n  const newLatitudeRadians = newLatitudeOfObject(currentLatRad, angularDistance, directionRad);\n  const newLongitudeRadians = newLongitudeOfObject(currentLatRad, currentLongRad, newLatitudeRadians, angularDistance, directionRad);\n  return [toDegrees(newLatitudeRadians), toDegrees(newLongitudeRadians)];\n};\n\nexport const predictLoc = (currentData, distance) => {\n  if (currentData == null || distance == null) {\n    return [0, 0];\n  }\n\n  const latitude = currentData.latitude;\n  const longitude = currentData.longitude;\n  const direction = currentData.direction;\n  return calculateNewPositionOfObject(latitude, longitude, distance, direction);\n};","map":{"version":3,"sources":["C:/Users/James Pan/Documents/UBC/demo/groundstationweb/src/helpers/location.js"],"names":["newLatitudeOfObject","currentLatRad","angularDistance","directionRad","Math","asin","sin","cos","newLongitudeOfObject","currentLongRad","newLatRad","atan2","toDegrees","rad","PI","toRadians","angle","calcAngularDistance","distance","earthRadius","feetInM","distanceInM","calculateNewPositionOfObject","currentLatitude","currentLongitude","direction","newLatitudeRadians","newLongitudeRadians","predictLoc","currentData","latitude","longitude"],"mappings":"AAAA,MAAMA,mBAAmB,GAAG,CAACC,aAAD,EAAgBC,eAAhB,EAAiCC,YAAjC,KAAkD;AAC5E,SAAOC,IAAI,CAACC,IAAL,CAAUD,IAAI,CAACE,GAAL,CAASL,aAAT,IAAwBG,IAAI,CAACG,GAAL,CAASL,eAAT,CAAxB,GACTE,IAAI,CAACG,GAAL,CAASN,aAAT,IAAwBG,IAAI,CAACE,GAAL,CAASJ,eAAT,CAAxB,GAAkDE,IAAI,CAACG,GAAL,CAASJ,YAAT,CADnD,CAAP;AAED,CAHD;;AAKA,MAAMK,oBAAoB,GAAG,CAACP,aAAD,EAAgBQ,cAAhB,EAAgCC,SAAhC,EAA2CR,eAA3C,EAA4DC,YAA5D,KAA6E;AACxG,SAAOM,cAAc,GAAGL,IAAI,CAACO,KAAL,CAAWP,IAAI,CAACE,GAAL,CAASH,YAAT,IAAuBC,IAAI,CAACE,GAAL,CAASJ,eAAT,CAAvB,GAAiDE,IAAI,CAACG,GAAL,CAASN,aAAT,CAA5D,EACtBG,IAAI,CAACG,GAAL,CAASL,eAAT,IAA0BE,IAAI,CAACE,GAAL,CAASL,aAAT,IAAwBG,IAAI,CAACE,GAAL,CAASI,SAAT,CAD5B,CAAxB;AAED,CAHD;;AAKA,MAAME,SAAS,GAAIC,GAAD,IAAS;AACzB,SAAOA,GAAG,GAAG,GAAN,GAAYT,IAAI,CAACU,EAAxB;AACD,CAFD;;AAIA,MAAMC,SAAS,GAAIC,KAAD,IAAW;AAC3B,SAAOA,KAAK,GAAGZ,IAAI,CAACU,EAAb,GAAkB,GAAzB;AACD,CAFD,C,CAIA;AACA;;;AACA,MAAMG,mBAAmB,GAAIC,QAAD,IAAc;AACxC,QAAMC,WAAW,GAAG,OAApB,CADwC,CACX;;AAC7B,QAAMC,OAAO,GAAG,KAAhB,CAFwC,CAEjB;;AACvB,QAAMC,WAAW,GAAGH,QAAQ,GAAGE,OAA/B;AAEA,SAAOC,WAAW,GAAGF,WAArB;AACD,CAND,C,CAQA;AACA;;;AACA,MAAMG,4BAA4B,GAAG,CAACC,eAAD,EAAkBC,gBAAlB,EAAoCN,QAApC,EAA8CO,SAA9C,KAA4D;AAC/F,QAAMvB,eAAe,GAAGe,mBAAmB,CAACC,QAAD,CAA3C;AAEA,QAAMjB,aAAa,GAAGc,SAAS,CAACQ,eAAD,CAA/B;AACA,QAAMd,cAAc,GAAGM,SAAS,CAACS,gBAAD,CAAhC;AACA,QAAMrB,YAAY,GAAGY,SAAS,CAACU,SAAD,CAA9B;AAEA,QAAMC,kBAAkB,GAAG1B,mBAAmB,CAACC,aAAD,EAAgBC,eAAhB,EAAiCC,YAAjC,CAA9C;AACA,QAAMwB,mBAAmB,GAAGnB,oBAAoB,CAACP,aAAD,EAAgBQ,cAAhB,EAC9CiB,kBAD8C,EAC1BxB,eAD0B,EACTC,YADS,CAAhD;AAGA,SAAO,CAACS,SAAS,CAACc,kBAAD,CAAV,EAAgCd,SAAS,CAACe,mBAAD,CAAzC,CAAP;AACD,CAZD;;AAcA,OAAO,MAAMC,UAAU,GAAG,CAACC,WAAD,EAAcX,QAAd,KAA2B;AACnD,MAAIW,WAAW,IAAI,IAAf,IAAuBX,QAAQ,IAAI,IAAvC,EAA6C;AAC3C,WAAO,CAAC,CAAD,EAAI,CAAJ,CAAP;AACD;;AAHkD,QAK3CY,QAL2C,GAK9BD,WAL8B,CAK3CC,QAL2C;AAAA,QAM3CC,SAN2C,GAM7BF,WAN6B,CAM3CE,SAN2C;AAAA,QAO3CN,SAP2C,GAO7BI,WAP6B,CAO3CJ,SAP2C;AASnD,SAAOH,4BAA4B,CAACQ,QAAD,EAAWC,SAAX,EAAsBb,QAAtB,EAAgCO,SAAhC,CAAnC;AACD,CAVM","sourcesContent":["const newLatitudeOfObject = (currentLatRad, angularDistance, directionRad) => {\n  return Math.asin(Math.sin(currentLatRad)*Math.cos(angularDistance)\n        + Math.cos(currentLatRad)*Math.sin(angularDistance)*Math.cos(directionRad));\n};\n\nconst newLongitudeOfObject = (currentLatRad, currentLongRad, newLatRad, angularDistance, directionRad) => {\n  return currentLongRad + Math.atan2(Math.sin(directionRad)*Math.sin(angularDistance)*Math.cos(currentLatRad),\n    Math.cos(angularDistance)-Math.sin(currentLatRad)*Math.sin(newLatRad));\n};\n\nconst toDegrees = (rad) => {\n  return rad * 180 / Math.PI;\n};\n\nconst toRadians = (angle) => {\n  return angle * Math.PI / 180;\n};\n\n// Calculate the angular distance w.r.t mean earth radius\n// Assumes distance in ft;\nconst calcAngularDistance = (distance) => {\n  const earthRadius = 6378100; // average earth radius in m;\n  const feetInM = 3.218; // number of ft in 1m\n  const distanceInM = distance / feetInM;\n\n  return distanceInM / earthRadius;\n};\n\n// Calculate new position of object in degrees (latitude & longitude)\n// based on https://www.movable-type.co.uk/scripts/latlong.html#dest-point\nconst calculateNewPositionOfObject = (currentLatitude, currentLongitude, distance, direction) => {\n  const angularDistance = calcAngularDistance(distance);\n\n  const currentLatRad = toRadians(currentLatitude);\n  const currentLongRad = toRadians(currentLongitude);\n  const directionRad = toRadians(direction);\n\n  const newLatitudeRadians = newLatitudeOfObject(currentLatRad, angularDistance, directionRad);\n  const newLongitudeRadians = newLongitudeOfObject(currentLatRad, currentLongRad,\n    newLatitudeRadians, angularDistance, directionRad);\n\n  return [toDegrees(newLatitudeRadians), toDegrees(newLongitudeRadians)];\n};\n\nexport const predictLoc = (currentData, distance) => {\n  if (currentData == null || distance == null) {\n    return [0, 0];\n  }\n\n  const { latitude } = currentData;\n  const { longitude } = currentData;\n  const { direction } = currentData;\n\n  return calculateNewPositionOfObject(latitude, longitude, distance, direction);\n};\n"]},"metadata":{},"sourceType":"module"}