{"ast":null,"code":"import rungeKutta4 from 'ode-rk4';\n/* Predictions.js takes in information about an object being dropped from a moving\r\nplane and calculates the object's predicted distance (x-position) from its origin (x0, y0)\r\nonce it reaches the ground (y = height = 0).\r\n\r\nIt requires a system of 4 ODEs, and uses an implementation of RungeKutta (rk4) in ode-rk4 library.\r\nto solve the system.\r\n\r\nAll units are calculated in metric system. The program assumes an input in ft and thus produces an output in ft.\r\nInitial altitude is in ft, velocity should be in [m/s].\r\n\r\nThe code below is based on the following paper\r\n https://www.phys.uconn.edu/~rozman/Courses/P2200_14F/downloads/glider/glider-2014-11-05.pdf\r\n All variable names have been translated to descriptive variables\r\n ## notation indicates the equivalent variable used in the paper for reference\r\n [ ] notation indicates units\r\n*/\n\nlet headwindScaled = 0; // declared global to be passed into functions without being integrated\n\nlet CDA_CL = 0.9,\n    CDA_CD = 0.3,\n    PAYLOAD_CD = 3.75;\nexport const predict = (currentAltitude, initialVelocity, mass, wingArea, dragOrLiftScalingFactor, derivFunctions) => {\n  //----------- Constants-----------\n  //________________________________\n  let m2ft = 3.281,\n      //#of ft in 1 m\n  gravity = 9.81; // ## g [m/s^2]\n  // air density at sea level & 15ºC, may need to be adjusted\n\n  let airDensity = 1.2; //## rho -> 𝞺 [kg/m^3]\n  // -----------Dependent Variables-----------\n  //__________________________________________\n  // scaling factors for dimensionless variables, no units.\n\n  let velocityScalingFactor, //## vt\n  distanceScalingFactor; //## lc\n  // √[(m * g) /(1/2)(𝞺)(Cd or Cl)(S)], ### dragOrLiftScalingFactor = Cd or Cl based on desired application, S = wingArea, 𝞺 = air density\n\n  velocityScalingFactor = Math.sqrt(mass * gravity / (0.5 * airDensity * dragOrLiftScalingFactor * wingArea)); //## vt\n\n  distanceScalingFactor = velocityScalingFactor ** 2 / gravity; //## lc -> = vt^2/g\n  // Initial Conditions\n\n  let initialDistance = 0 / m2ft,\n      //## x0 [m] -> initial distance in x position of object, corresponds to pos of plane at drop\n  initialHeight = currentAltitude / m2ft,\n      //## y0 [m]\n  headwind = 0,\n      // [m/s]\n  initialAngle = 0; //## theta, [rad] -> angle w.r.t horizon, doesn't need to be dimensionless\n  // -----------Dimensionless Variables----------- (see linked paper for more info)\n  //______________________________________________\n\n  let initialDistanceScaled = initialDistance / distanceScalingFactor,\n      initialHeightScaled = initialHeight / distanceScalingFactor,\n      initialVelocityScaled = initialVelocity / velocityScalingFactor;\n  headwindScaled = headwind / velocityScalingFactor; //----------- Runge Kutta Integrator Variables-----------\n  //_______________________________________________________\n\n  let initialConditions = [initialVelocityScaled, initialAngle, initialDistanceScaled, initialHeightScaled]; // initial conditions in RK4 to be solved for\n\n  let numberOfSteps = 90; // number of maximum steps taken by RK4 to solve the system\n\n  let initalTime = 0; // start time\n\n  let h = 2.0 * Math.PI / numberOfSteps; // small number used as a coefficient in Runge Kutta Method\n  // Function to unscale variables after being solved using RK4\n\n  let unscale = function (output) {\n    return [output[0] * velocityScalingFactor, // returns unscaled velocity\n    output[1], // returns angle w.r.t horizon\n    output[2] * distanceScalingFactor * m2ft, // returns unscaled x position\n    output[3] * distanceScalingFactor * m2ft // returns unscaled y position\n    ];\n  }; //----------- Solve System of ODE & return result-----------\n  //_______________________________________________________\n\n\n  let rk4Solver = rungeKutta4(initialConditions, derivFunctions, initalTime, h);\n  let output; // solve ODE using RK4, stop once object has hit the ground (y[3] = height = 0)\n\n  do {\n    output = rk4Solver.step();\n  } while (output.y[3] > 0); // check if object has reach ground\n\n\n  return unscale(output.y)[2]; // return x position after object reaches ground\n}; // Prediction Setup for an object dropped from a plane\n\nexport const predictPayload = (altitude, velocity) => {\n  if (velocity <= 0.05) {\n    return 0;\n  } //coeffDrag = PAYLOAD_CD, //## Cd\n\n\n  let mass = 0.5,\n      //## m [kg]\n  wingArea = 0.019; //## S [m^2]\n  // dydt[] = derivative functions for each of θ, v, x, y.\n  // y -> y[0] = v, y[1] = theta\n\n  let derivFunctions = function (dydt, y) {\n    dydt[0] = -Math.sin(y[1]) - y[0] * y[0]; //## dvdt\n\n    dydt[1] = -Math.cos(y[1]) / y[0]; //## dθdt\n\n    dydt[2] = y[0] * Math.cos(y[1]); //## dxdt\n\n    dydt[3] = y[0] * Math.sin(y[1]); //## dydt\n  };\n\n  return predict(altitude, velocity, mass, wingArea, PAYLOAD_CD, derivFunctions);\n}; // Prediction setup for a glider released from a plane\n\nexport const predictCDA = (altitude, velocity) => {\n  if (velocity <= 0.05) {\n    return 0;\n  } //coeffLift = CDA_CL,// ## Cl\n  //coeffDrag = CDA_CD,// ## Cd\n\n\n  let mass = 0.227,\n      // ## m [kg]\n  wingArea = 0.056; //## S [m^2]\n\n  let liftToDragRatio = CDA_CL / CDA_CD; // ## R -> Glide Ratio\n  // dydt[] = derivative functions for each of θ, v, x, y.\n  // y -> y[0] = v, y[1] = theta\n\n  let deriv = function (dydt, y) {\n    dydt[0] = -Math.sin(y[1]) - y[0] ** 2 / liftToDragRatio; //## dvdt\n\n    dydt[1] = -Math.cos(y[1]) / y[0] + y[0]; //## dθdt\n\n    dydt[2] = y[0] * Math.cos(y[1]) - headwindScaled; //## dxdt // scaledHeadwind needs to be constant\n\n    dydt[3] = y[0] * Math.sin(y[1]); //## dydt\n  };\n\n  return predict(altitude, velocity, mass, wingArea, CDA_CL, deriv);\n};","map":{"version":3,"sources":["C:\\Users\\James Pan\\Desktop\\demo\\groundstationweb\\src\\helpers\\predictions.js"],"names":["rungeKutta4","headwindScaled","CDA_CL","CDA_CD","PAYLOAD_CD","predict","currentAltitude","initialVelocity","mass","wingArea","dragOrLiftScalingFactor","derivFunctions","m2ft","gravity","airDensity","velocityScalingFactor","distanceScalingFactor","Math","sqrt","initialDistance","initialHeight","headwind","initialAngle","initialDistanceScaled","initialHeightScaled","initialVelocityScaled","initialConditions","numberOfSteps","initalTime","h","PI","unscale","output","rk4Solver","step","y","predictPayload","altitude","velocity","dydt","sin","cos","predictCDA","liftToDragRatio","deriv"],"mappings":"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","sourcesContent":["import rungeKutta4 from 'ode-rk4';\r\n\r\n/* Predictions.js takes in information about an object being dropped from a moving\r\nplane and calculates the object's predicted distance (x-position) from its origin (x0, y0)\r\nonce it reaches the ground (y = height = 0).\r\n\r\nIt requires a system of 4 ODEs, and uses an implementation of RungeKutta (rk4) in ode-rk4 library.\r\nto solve the system.\r\n\r\nAll units are calculated in metric system. The program assumes an input in ft and thus produces an output in ft.\r\nInitial altitude is in ft, velocity should be in [m/s].\r\n\r\nThe code below is based on the following paper\r\n https://www.phys.uconn.edu/~rozman/Courses/P2200_14F/downloads/glider/glider-2014-11-05.pdf\r\n All variable names have been translated to descriptive variables\r\n ## notation indicates the equivalent variable used in the paper for reference\r\n [ ] notation indicates units\r\n*/\r\n\r\nlet headwindScaled = 0; // declared global to be passed into functions without being integrated\r\nlet CDA_CL = 0.9,\r\n    CDA_CD = 0.3,\r\n    PAYLOAD_CD = 3.75\r\n\r\nexport const predict = (currentAltitude, initialVelocity, mass, wingArea, dragOrLiftScalingFactor, derivFunctions) => {\r\n\r\n\r\n\r\n    //----------- Constants-----------\r\n    //________________________________\r\n    let m2ft = 3.281, //#of ft in 1 m\r\n        gravity = 9.81;// ## g [m/s^2]\r\n\r\n    // air density at sea level & 15ºC, may need to be adjusted\r\n    let airDensity = 1.2; //## rho -> 𝞺 [kg/m^3]\r\n\r\n\r\n\r\n\r\n    // -----------Dependent Variables-----------\r\n    //__________________________________________\r\n\r\n    // scaling factors for dimensionless variables, no units.\r\n    let velocityScalingFactor, //## vt\r\n        distanceScalingFactor; //## lc\r\n\r\n    // √[(m * g) /(1/2)(𝞺)(Cd or Cl)(S)], ### dragOrLiftScalingFactor = Cd or Cl based on desired application, S = wingArea, 𝞺 = air density\r\n    velocityScalingFactor = Math.sqrt(mass * gravity/( 0.5 * airDensity * dragOrLiftScalingFactor * wingArea)); //## vt\r\n    distanceScalingFactor = (velocityScalingFactor ** 2) / gravity; //## lc -> = vt^2/g\r\n\r\n\r\n\r\n    // Initial Conditions\r\n    let initialDistance = 0/m2ft, //## x0 [m] -> initial distance in x position of object, corresponds to pos of plane at drop\r\n        initialHeight = currentAltitude/m2ft, //## y0 [m]\r\n        headwind = 0, // [m/s]\r\n        initialAngle = 0; //## theta, [rad] -> angle w.r.t horizon, doesn't need to be dimensionless\r\n\r\n\r\n\r\n\r\n    // -----------Dimensionless Variables----------- (see linked paper for more info)\r\n    //______________________________________________\r\n    let initialDistanceScaled = initialDistance/distanceScalingFactor,\r\n        initialHeightScaled = initialHeight/distanceScalingFactor,\r\n        initialVelocityScaled = initialVelocity/velocityScalingFactor;\r\n        headwindScaled = headwind/velocityScalingFactor;\r\n\r\n\r\n\r\n\r\n    //----------- Runge Kutta Integrator Variables-----------\r\n    //_______________________________________________________\r\n    let initialConditions = [initialVelocityScaled, initialAngle, initialDistanceScaled, initialHeightScaled] // initial conditions in RK4 to be solved for\r\n    let numberOfSteps = 90 // number of maximum steps taken by RK4 to solve the system\r\n    let initalTime = 0 // start time\r\n    let h = 2.0 * Math.PI / numberOfSteps // small number used as a coefficient in Runge Kutta Method\r\n\r\n\r\n    // Function to unscale variables after being solved using RK4\r\n    let unscale = function(output) {\r\n        return [\r\n            output[0] * velocityScalingFactor, // returns unscaled velocity\r\n            output[1],                         // returns angle w.r.t horizon\r\n            output[2] * distanceScalingFactor * m2ft, // returns unscaled x position\r\n            output[3] * distanceScalingFactor * m2ft // returns unscaled y position\r\n        ];\r\n    }\r\n\r\n\r\n\r\n\r\n    //----------- Solve System of ODE & return result-----------\r\n    //_______________________________________________________\r\n    let rk4Solver = rungeKutta4( initialConditions, derivFunctions, initalTime, h )\r\n\r\n    let output;\r\n    // solve ODE using RK4, stop once object has hit the ground (y[3] = height = 0)\r\n    do {\r\n        output = rk4Solver.step()\r\n    } while (output.y[3] > 0) // check if object has reach ground\r\n\r\n    return unscale(output.y)[2]; // return x position after object reaches ground\r\n}\r\n\r\n// Prediction Setup for an object dropped from a plane\r\nexport const predictPayload = (altitude, velocity) => {\r\n\r\n    if (velocity <= 0.05){\r\n        return 0;\r\n    }\r\n\r\n        //coeffDrag = PAYLOAD_CD, //## Cd\r\n    let mass = 0.5,       //## m [kg]\r\n        wingArea = 0.019; //## S [m^2]\r\n\r\n    // dydt[] = derivative functions for each of θ, v, x, y.\r\n    // y -> y[0] = v, y[1] = theta\r\n    let derivFunctions = function (dydt, y) {\r\n        dydt[0] = -Math.sin(y[1]) - (y[0] * y[0]) //## dvdt\r\n        dydt[1] = -Math.cos(y[1]) / y[0] //## dθdt\r\n        dydt[2] = y[0] * Math.cos(y[1])//## dxdt\r\n        dydt[3] = y[0] * Math.sin(y[1]) //## dydt\r\n    }\r\n\r\n    return predict(altitude, velocity, mass, wingArea, PAYLOAD_CD, derivFunctions)\r\n}\r\n\r\n// Prediction setup for a glider released from a plane\r\nexport const predictCDA = (altitude, velocity) => {\r\n\r\n    if (velocity <= 0.05){\r\n        return 0;\r\n    }\r\n         //coeffLift = CDA_CL,// ## Cl\r\n        //coeffDrag = CDA_CD,// ## Cd\r\n    let mass = 0.227,   // ## m [kg]\r\n        wingArea = 0.056; //## S [m^2]\r\n\r\n    let liftToDragRatio = CDA_CL/CDA_CD; // ## R -> Glide Ratio\r\n\r\n    // dydt[] = derivative functions for each of θ, v, x, y.\r\n    // y -> y[0] = v, y[1] = theta\r\n    let deriv = function (dydt, y) {\r\n        dydt[0] = -Math.sin(y[1]) - (y[0] ** 2)/liftToDragRatio; //## dvdt\r\n        dydt[1] = -Math.cos(y[1]) / y[0] + y[0] //## dθdt\r\n        dydt[2] = y[0] * Math.cos(y[1]) - headwindScaled //## dxdt // scaledHeadwind needs to be constant\r\n        dydt[3] = y[0] * Math.sin(y[1]) //## dydt\r\n    }\r\n    return predict(altitude, velocity, mass, wingArea, CDA_CL, deriv);\r\n}"]},"metadata":{},"sourceType":"module"}